## 1.7 의존관계 주입(DI)

### 1.7.2 런타임 의존관계 설정

A가 B에 의존한다

- A에서 B에 정의된 메서드를 사용하는 경우 → 사용에 대한 의존 관계
- B의 변경은 A에게 영향을 미친다
- A의 변경은 B에게 영향을 미치지 않는다
- 의존 관계는 방향성이 있다
- **인터페이스**를 통해 관계를 주면 결합도가 낮아져 변경에 대한 자유도가 증가한다
    
    > UserDao가 ConnectionMaker를 사용하지만, 인터페이스로 관계되어있어 ConnectionMaker가 어떤 클래스로 구현되었는가는 영향을 미치지 않는다.
    ⇒ UserDao 클래스는 ConnectionMaker에 직접 의존
    > 

**의존 관계 주입**

: **제 3의 존재**가 런타임 시에 사용 대상인 의존 오브젝트와 사용하는 오브젝트를 연결하는 것

- 제 3의 존재: DaoFactory, 애플리케이션 컨텍스트, IoC 컨테이너 ...
- 사용하는 오브젝트가 수동적으로 사용할 오브젝트를 **주입** 받아 사용 → IoC 개념과도 잘 맞음
- 주입 = 오브젝트에 무엇인가를 넣어준다 = 파라미터로 오브젝트의 레퍼런스 전달 ⇒ 생성자를 이용

### 1.7.3 의존관계 검색과 주입

- 자신이 필요한 의존 오브젝트를 능동적으로 찾는다
- 어떤 클래스 오브젝트를 이용할지 결정하는 것은 아님 → IoC의 권한
- 이 오브젝트를 가져올 때 메서드나 생성자를 통한 주입 말고 **스스로 컨테이너에게 요청**

> DaoFactory daoFactory = new DaoFactory();
this.ConnectionMaker = daoFactory.connectionMaker();
> 
- 어떤 오브젝트 클래스를 사용하는 지는 모르고 여전히 의존 대상은 ConnectionMaker 인터페이스
- DI와 다른 것은 외부로부터의 주입이 아닌 스스로 선택(DaoFactory)한다는 것
- 스프링의 getBean() 메서드를 이용하면 의존관계 검색 쉽게 가능

> this.connectionMaker = context.getBean("~", ~);
> 

DI를 이용하는 것이 코드를 작성하는 것에 있어 DL 보다 단순하고 깔끔함, 그렇다면 언제 DL을 이용할까?

- DI는 주입하는 객체, 주입되는 객체 모두 빈이어야 한다
- **빈이 아닌 오브젝트에서 다른 오브젝트를 사용할 때 의존관계 검색을 이용한다**
