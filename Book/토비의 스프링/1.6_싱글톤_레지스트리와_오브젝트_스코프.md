## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### DaoFactory를 사용하는 것과 Annotation을 이용하는 것의 차이점

- DaoFactory는 userDao()를 호출할 때마다 새로운 객체를 생성하여 반환한다 → 여러개의 객체
- IoC 컨테이너를 이용하면, userDao 빈 오브젝트가 없다면 생성하고, 있다면 있는 것을 사용한다 → 하나의 객체

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

애플리케이션 컨텍스트는 **IoC 컨테이너**인 동시에 **싱글톤 레지스트리**이다.

- 싱글톤 레지스트리
    
    서버에서 동작하는 코드로 생각했을 때 클라이언트의 요청이 들어올 때마다 객체를 생성하는 것은 서버가 감당하기 힘든 부하를 낳는다.
    
    ⇒ **서블릿은 멀티스레드 환경에서 싱글톤으로 동작**
    
    사용자의 요청을 담당하는 스레드 별 하나의 오브젝트를 공유해 동시에 사용
    
- 싱글톤 패턴 구현 방식의 문제점
    1. private 생성자를 갖고 있기 때문에 상속할 수 없다 → 다형성 적용 불가
    2. 테스트하기 힘들다: 만들어지는 방식이 제한적이기 때문
    3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다 → 클래스 로더의 구성에 따라 달라짐, 여러 개의 JVM에 분산되어 설치가 되는 경우에도 독립적으로 오브젝트 생성됨
    4. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다 → 어디에서나 접근 가능하고, 수정, 공유할 수 있다
- 이러한 단점을 보완하여 스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공 ⇒ **싱글톤 레지스트리**
    - private 생성자를 이용하는 것이 아닌 평범한 자바 class를 싱글톤으로 사용가능
    - 테스트를 위한 목 오브젝트로 대체하는 것도 간단: 생성자 파라미터를 이용해서 사용할 오브젝트를 넣어줄 수 있음
    - 객체지향적인 설계 방식과 원칙, 디자인 패턴을 적용하는데 제약이 없다

### 1.6.2 싱글톤과 오브젝트의 상태

싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 **상태정보를 내부에 갖고 있지 않은** **무상태 방식**으로 만들어져야 한다.

→ 다중 사용자가 인스턴스 변수를 수정할 수 있다면 동시성 문제 발생

→ 읽기 전용 값이라면 인스턴스 변수를 사용해도 된다.

⇒ **파라미터와 로컬변수, 리턴 값을 이용**하여 정보를 다루자! (메서드 안의 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어진다.)

### 1.6.3 스프링 빈의 스코프

: 빈이 생성되고, 존재하고, 적용되는 범위

- 싱글톤 스코프 (기본 스코프) → 컨테이너 내에 한 개의 오브젝트만 만들어진다
- 프로토타입 스코프: 빈을 요청할 때마다 새로운 오브젝트 만들어 줌
- 요청 스코프: 웹을 통한 HTTP 요청이 생길 때 마다
- 세션 스코프: 웹의 세션과 스코프가 유사