## 문제 해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다. (손으로 로직 작성)
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

<br/>

## 체계적인 접근을 위한 질문

- 비슷한 문제를 풀어본 적이 있나?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 단순화할 수 있을까?
- 그림으로 그려 볼 수 있을까?
- 수식으로 표현할 수 있을까? (어려운 편.. )
- 문제를 분해할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?

<br/>

## 좋은 알고리즘이란

1. 정확성: 얼마나 정확하게 동작하는가
2. 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가 (수행 시간) ⇒ 시간복잡도
3. 메모리 사용량: 얼마나 적은 메모리를 사용하는가 ⇒ 공간복잡도
4. 단순성: 얼마나 단순한가 (가독성 → 유지보수성 증가)
5. 최적성: 더 이상 개선할 여지 없이 최적화되었는가

<br/>

## 알고리즘 성능

**복잡도의 점근적 표기**

: 시간 또는 공간 복잡도는 입력 크기에 대한 함수로 표기하는데, 점근적으로 표기한다.

- 실행 횟수로 시간 복잡도를 표기

**빅-오(O) 표기법**

: 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

- 계수는 생략하여 표시
- O($2n^2$+$3n+2$) = O($n^2$)
- O(4) = O(1)