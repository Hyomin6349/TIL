## 0-1 Knapsack 문제

: 무게와 가치를 가진 물건들이 주어지고, 무게가 W가 넘지 않으며 최대의 가치를 찾는 문제

- 물건은 넣거나 안 넣거나. 쪼갤 수 없음
- 해결법
    1. 가치가 큰 순서대로 담기 → x
    2. 가벼운 순서대로 담기 → x
    3. 무게당 가치가 큰 순서대로 담기 → 물건을 쪼갤 수 있는 경우에만 답이 될 수 있음 x
    4. **물건을 하나씩 배낭에 담으면서 최적의 가치 찾기**

    → i 번째 물건에 대해

    담는다: i-1 번째 물건까지 고려한 (W-Wi) 무게의 최대 가치 + Vi

    안 담는다: i-1 번째 물건까지 고려한 W 무게의 최대가치

    ⇒ 둘 중의 max 값이 i번째 물건까지 고려한 W 무게를 담는 최대 가치

<br>

## 구현

- W : 배낭의 용량
- (Vi, Wi): i번째 물건의 가치와 무게
- K(i, w) : i번째 물건까지 고려한 w 무게를 만들 때의 최대 가치 → 2차원 배열 필요!
- K(i, w)는 아래 값 중 하나
    - 0: i 혹은 w가 0인 경우
    - K(i-1, w): i 번째 물건을 배낭에 넣을 수 없는 경우 (넣으면 무게 초과)
    - max(Vi + K(i-1, w-Wi), K(i-1, w)): i번째 물건을 넣거나 안 넣거나를 모두 고려했을 때 더 큰 값

**즉, K(i-1, w-Wi)와 K(i-1, w)가 구해져 있으면 K(i, w)를 구할 수 있다!**

상향식의 경우엔 모든 w에 대한 값을 계산해두어야 하고 (이후에 어떤 w가 필요할지 모름), 하향식의 경우에는 필요한 값만 계산하면 됨

<br>

## 코드

```java
int[][] D = new int[N+1][W+1];
		
for(int i=1;i<=N;i++) {
	for(int w=1;w<=W; w++) {
		if(weights[i] <= w) { //물건을 넣을 수 있는 경우
			D[i][w] = Math.max(profits[i]+D[i-1][w-weights[i]], D[i-1][w]);
		}
		else { //물건을 넣을 수 없는 경우
			D[i][w] = D[i-1][w];
		}
	}
}
```

<br>

## 일차원 배열로 구하기

- 결국 K(i, w)는 K(i-1, w)를 고려하여 최적해를 구해나감

     ⇒ 모든 i에 대한 배열을 가지고 있을 필요가 없음, 그렇다면 2개의 배열을 사용?

- **뒤쪽부터 값을 업데이트해** 나가면 배열 한개로 최적값을 가지고 있을 수 있다
    - 이 배열의 앞쪽은 i-1에 대한 최적값을 가지고 뒤쪽은 i에 대한 최적값을 가진 상태
    - i 물건을 고려할 때 물건을 넣을 수 없는 경우, i-1의 최적해를 그대로 가지고 오기 때문에 가능한 일
    - 물건을 넣을 수 없는 경우는 고려하지 않음

```java
int[] D = new int[W+1];
		
for(int i=1;i<=N;i++) {
	for(int w=W;w>=weights[i]; w--) {
		D[w] = Math.max(profits[i]+D[w-weights[i]], D[w]);
	}
}
```

- 가치의 최적해를 구할 때는 적합한 코드
- 어떤 물건이 담겼는지 담기지 않았는지는 알 수 없음